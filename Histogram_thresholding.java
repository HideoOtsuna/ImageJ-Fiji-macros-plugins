import ij.*;import ij.plugin.filter.*;import ij.plugin.PlugIn;import ij.process.*;import ij.gui.*;import java.awt.*;import ij.macro.*;import ij.gui.GenericDialog.*;import java.math.*;public class Histogram_thresholding implements PlugInFilter{	ImagePlus imp;	//	String origi;	//	String origi = imp.getTitle();	int nslice=0;	int maxvalue=0;	int measuregap=0;	int startval=0;	double sd=0;	double avesd=0;	double insideSD=0;	int histo=0;	double sqinside=0;	int attenuationN=0;	String attenuationMe;	int realstart=0;	double minff=10000;	double ffmin=0;	double thresval=0;	int end0 = 0;	double attenvalue=0;	int step=0; 	boolean logon = true;	boolean titleon=true;		public int setup(String arg, ImagePlus imp){		IJ.register (Histogram_thresholding.class);		if (IJ.versionLessThan("1.32c")){			IJ.showMessage("Error", "Please Update ImageJ.");			return 0;		}				step = (int)Prefs.get("step.int", 1);		logon = (boolean)Prefs.get("logon.boolean", true);		titleon = (boolean)Prefs.get("titleon.boolean", true);				String [] attenuation = {"Yes", "No"};				GenericDialog gd = new GenericDialog("Background thresholding");		gd.addSlider("Z-attenuation collection strength X ", 1.0, 2.0, 2);				gd.addNumericField("How many steps of the thresholding value detection 1-5", step, 0);		gd.addCheckbox("Show log",logon);		gd.addCheckbox("Set title as thresholding value",titleon);				gd.showDialog();		if(gd.wasCanceled()){			return 0;		}				attenvalue=(double)gd.getNextNumber();		attenvalue=1/attenvalue;				step = (int)gd.getNextNumber();		logon = gd.getNextBoolean();		titleon = gd.getNextBoolean();						Prefs.set("step.int", step);		Prefs.set("logon.boolean", logon);		Prefs.set("titleon.boolean", titleon);				int[] wList = WindowManager.getIDList();		if (wList==null) {			IJ.error("No images are open.");			return 0;		}		//	IJ.log(" wList;"+String.valueOf(wList));		imp = WindowManager.getCurrentImage();		this.imp = imp;		if(imp.getType()!=imp.GRAY8 && imp.getType()!=imp.GRAY16 ){//&& imp.getType()!=imp.GRAY32			IJ.showMessage("Error", "Plugin requires 8- or 16-bit image");			return 0;		}				return DOES_8G+DOES_16;	}		public void run(ImageProcessor ip){		int histogramWidthhalf=0;				if(imp.getType()==imp.GRAY8){			histogramWidthhalf=5;		}else if(imp.getType()==imp.GRAY16){			histogramWidthhalf=100;		}				nslice = imp.getNSlices();		int pix = 0;		int ww = ip.getWidth() ;		int hh = ip.getHeight();		int sumpx = ip.getPixelCount();		ImageStack stack = imp.getStack();				for(int sliceposi=1; sliceposi<=nslice; sliceposi++){			int minVal=2000000000;			int maxVal=0;				///////////findMinAndMax////////////////////			for(int i=0; i<sumpx; i++){				pix = ip.get (i);								if(pix>maxVal)				maxVal=pix;				else if(pix<minVal)				minVal=pix;			}					int histogap=maxVal-minVal;			int[] histogram = new int[maxVal+1];			int histStart=0;					int histgramWidth=histogramWidthhalf*2;//real width of searching histogram			BigDecimal BighistgramWidth = BigDecimal.valueOf(histgramWidth);			//		IJ.log("141; minVal; "+minVal+"  maxVal; "+maxVal);						if(nslice>1)			ip = stack.getProcessor(sliceposi);			int histoLarge=0;			int Largevalue=0;	////Histgram creation:///////			for(int i=0; i<sumpx; i++){				pix = ip.get (i);									if(pix>0){					histogram[pix]=histogram[pix]+1;										if(histogram[pix]>histoLarge){						histoLarge=histogram[pix];						Largevalue=pix;					}				}			}//		for(int i=0; i<sumpx; i++){					//	IJ.log("159 minVal; "+minVal+"  maxVal; "+maxVal+"  histoLarge; "+histoLarge+"  Largevalue; "+Largevalue);			///////background detection, start value decision///////////////////			int maxhistoVal=0;			int maxhistoVal2=0;			int maxhistoValval=0;						for(int backgroundVal=histogramWidthhalf+minVal; backgroundVal<=maxVal-histogramWidthhalf; backgroundVal++){								if(nslice==1)				IJ.showProgress (backgroundVal-histogramWidthhalf+1, maxVal-histogramWidthhalf);								//BigDecimal backgroundValN=new BigDecimal("0.00");			//	BigDecimal backgroundValSum=new BigDecimal("0.00");				int backgroundValN=0;								for(int histogramW=backgroundVal-histogramWidthhalf; histogramW<backgroundVal+histogramWidthhalf; histogramW++){					int histval=histogram[histogramW];// just for histogramWidthhalf region										if(histval>0){						backgroundValN=histval+backgroundValN;												if(histval>maxhistoVal2){							maxhistoVal2=histval;							maxhistoValval=histogramW;						}						//BigDecimal backgroundValN=BigDecimal.valueOf(histval);					//	backgroundValSum=backgroundValSum.add(backgroundValN);					}				}								int backgroundAve2=backgroundValN/histgramWidth;//averaging value of histogramWidthhalf*2								//BigDecimal backgroundAve=backgroundValSum.divide(BighistgramWidth, 3, BigDecimal.ROUND_HALF_UP);//averaging value from histo-width 				//int backgroundAve2=backgroundAve.intValue();								if(backgroundAve2>maxhistoVal){					maxhistoVal=backgroundAve2;//highest histo region value = Background value = start value					maxhistoValval=backgroundVal;									}else if (backgroundAve2>histoLarge/10 && backgroundAve2<maxhistoVal)// 1st time cref				backgroundVal=maxVal+1;// to the end, if decreased backgroundVal = histgram region value			}			int ff=Largevalue;//highest value of histogram = Background value = start value				/////// Thresholding value decision	////////////////////////					////depth attenuation weighting ////////////////////////////			if(attenvalue<1 && nslice>1){				double sliceposi1=sliceposi;				double nslice1=nslice;								double changeval=sliceposi1/nslice1;								double ff2=ff;				ff2=ff2-(ff2*attenvalue*changeval);				ff2=Math.round(ff2);				ff = (int) ff2;//Background value = start value				realstart=ff;				//	IJ.log("Attenuation"+changeval);			}//depth attenuation adjustment				//histgram increment setting//////////////////////			if(step==0)			step=1;			int HistoIncrement=0;			if(imp.getType()==imp.GRAY8){				HistoIncrement=1;			}else if(imp.getType()==imp.GRAY16){				HistoIncrement=histogap/2500;				histogramWidthhalf=histogap/1000;			}		//	else if(imp.getType()==imp.GRAY32)			//		HistoIncrement=50;			if(HistoIncrement<1)			HistoIncrement=1;						histgramWidth=histogramWidthhalf*2;						int recordnumber=maxVal/HistoIncrement;			double[] sdRecord = new double[recordnumber];			int sdRecordIncrement=0;			double sdIncrement=100;					//	IJ.log("235 ff; "+ff+"  maxhistoVal; "+maxhistoVal+"  maxhistoValval; "+maxhistoValval);	////////s.d measurement///////////////			int stepN=1;			while(stepN<=step){// multi step				end0 = 0;				minff=10000;								while(end0<maxVal){					int maxave=0;					if(ff>=maxVal-histogramWidthhalf-HistoIncrement){// error, cannot threshold						IJ.log("Cannot find bending value, no thresholding");						//			IJ.log("225 ff; "+ff);												if(titleon==true)						imp.setTitle(String.valueOf(ffmin));						return;					}else{											BigDecimal sumpre= new BigDecimal("0.00");											if(ff<histogramWidthhalf)// in case (ff-histogramWidthhalf) < 0						ff=histogramWidthhalf;						int sumpreint=0;							//1st histogram group average measurement/////////////////						for(int pre=ff-histogramWidthhalf; pre<=ff+histogramWidthhalf; pre++){							histo=histogram[pre];														sumpreint=sumpreint+histo;						//	BigDecimal eachhisto = BigDecimal.valueOf(histo);					//		sumpre=sumpre.add(eachhisto);						}											//BigDecimal avesd=sumpre.divide(BighistgramWidth, 3, BigDecimal.ROUND_HALF_UP);						//int ave2 = avesd.intValue();												int ave2=sumpreint/histgramWidth;												if(ave2>0){//maxhistoValval/10				//			IJ.log("242 ave2; "+ave2+"  ff; "+ff);													insideSD=0;			//2nd histogram group average measurement, increment is HistoIncrement /////////////////										for(int pre1=ff+HistoIncrement-histogramWidthhalf; pre1<=ff+HistoIncrement+histogramWidthhalf; pre1++){							histo=histogram[pre1];								insideSD=((histo-ave2)*(histo-ave2))+insideSD;							}							sqinside=insideSD/histogramWidthhalf*2;												sd = Math.sqrt(sqinside);														sdRecord[sdRecordIncrement]=sd;							sdRecordIncrement=sdRecordIncrement+1;														if(sdRecordIncrement>2){								sdIncrement = sd - sdRecord[sdRecordIncrement-2];								sdIncrement= Math.abs(sdIncrement);							}														if(sd>0)			//				IJ.log("257 sd; "+sd);							if(minff>sd){								minff=sd;								thresval=ff+histogramWidthhalf;								ffmin=Math.round(thresval);//threshold value							}							if(ffmin>1){								if(minff<sd){									if(sdIncrement<1)// closer signals, less sd change value									end0=maxVal;// to the end								}							}						}//if(ave2>0){						ff=ff+HistoIncrement;											}//if(ff>=maxVal-histogramWidthhalf-HistoIncrement){// error, cannot threshold				}//while(ff<maxvalue){				stepN=stepN+1;			}		//	if(ffmin>maxVal)		//	ffmin=maxVal;						if(nslice>1)			IJ.showProgress (sliceposi, nslice);//thresholding////////////////////////////			for(int i=0; i<sumpx; i++){				pix = ip.get (i);								if(pix>ffmin)				ip.set (i, maxVal);				else				ip.set (i, 0);							}//for(int i=0; i<sumpx; i++){			if(logon==true){// show log ON/OFF				if(nslice>1)				IJ.log("start value;	"+realstart+"	,Threshold val;	"+ffmin+"	,slice;	"+sliceposi);				else				IJ.log("start value;	"+Largevalue+"	,Threshold val;	"+ffmin+"	, step; "+step);			}			if(titleon==true)			imp.setTitle(String.valueOf(ffmin));		}		imp.show();	}}